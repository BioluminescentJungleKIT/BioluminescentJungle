#version 460

#ifdef USE_HW_RAYTRACING
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#endif

#include "geometry.glsl"
#include "restir.glsl"

layout(set = 0, binding = 0) uniform sampler2D albedo;
layout(set = 0, binding = 1) uniform sampler2D depth;
layout(set = 0, binding = 2) uniform sampler2D normal;
layout(set = 0, binding = 3) uniform sampler2D motion;

layout(set = 1, binding = 0) uniform writeonly image2D compositeLight;
layout(set = 1, binding = 1, std140) uniform LightInfoBlock {
    SceneLightInfo slInfo;
};

layout(std140, set = 1, binding = 2) readonly buffer PointLightIn {
    PointLight pointLights[];
};

layout(std140, set = 1, binding = 3) uniform Params {
    ivec2 lightGridSize;
    ivec2 lightGridOffset;
    vec2 lightGridCellSize;
    int nPointLights;
    int nTriangles;
    int nEmissiveTriangles;
};

#ifndef USE_HW_RAYTRACING
layout(std140, set = 1, binding = 4) readonly buffer TrianglesIn {
    Triangle tris[];
};
#endif

layout(std140, set = 1, binding = 5) readonly buffer EmissiveTrianglesIn {
    EmissiveTriangle emissiveTris[];
};

#ifndef USE_HW_RAYTRACING
layout(std140, set = 1, binding = 6) readonly buffer BVHIn {
    BVHNode bvh[];
};
#endif

layout(std430, set = 1, binding = 7) readonly buffer ReservoirsOld {
    Reservoir reservoirsOld[];
};

layout(std430, set = 1, binding = 8) writeonly buffer ReservoirsTmp {
    Reservoir reservoirsTmp[];
};

layout(std430, set = 1, binding = 10) readonly buffer LightGridIndices {
    int lightGrid[];
};

layout(std430, set = 1, binding = 11) readonly buffer LightGridOffsets {
    int lightGridStartOffset[];
};

#ifdef USE_HW_RAYTRACING
layout (set = 1, binding = 12) uniform accelerationStructureEXT topLevelAS;
#endif

layout(set = 2, binding = 0) uniform sampler2D prevAlbedo;
layout(set = 2, binding = 1) uniform sampler2D prevDepth;
layout(set = 2, binding = 2) uniform sampler2D prevNormal;
layout(set = 2, binding = 3) uniform sampler2D prevMotion;

#define MAX_STACK_SIZE 32

Ray getLightRay(SurfacePoint point, vec3 lightPos, out float len) {
    Ray lightRay;
    lightRay.origin = point.worldPos;
    lightRay.dir = lightPos - lightRay.origin;

    len = length(lightRay.dir);
    lightRay.dir /= len;
    lightRay.invDir = 1.0 / lightRay.dir;

    return lightRay;
}

#ifndef USE_HW_RAYTRACING
bool testShadowBruteforce(SurfacePoint point, vec3 lightPos) {
    float rayLen;
    Ray lightRay = getLightRay(point, lightPos, rayLen);

    const vec2 tmimaxInit = vec2(0.01, rayLen);
    for (int i = 0; i < nTriangles; i++) {
        float f = intersectTriangle(tris[i], lightRay);
        if (tmimaxInit.x <= f && f < tmimaxInit.y) {
            return true;
        }
    }

    return false;
}

bool doesIntersectAABB(int node, vec2 tmimaxInit, Ray lightRay) {
    vec3 aabb[2];
    aabb[0] = bvh[node].low.xyz;
    aabb[1] = bvh[node].high.xyz;

    vec2 isec = intersectAABB(aabb, lightRay, tmimaxInit);
    return isec.x <= isec.y;
}

int leftChild(BVHNode node) {
    return floatBitsToInt(node.low.w);
}

int rightChild(BVHNode node) {
    return floatBitsToInt(node.high.w);
}

bool testShadowAABB(SurfacePoint point, vec3 lightPos) {
    float rayLen;
    Ray lightRay = getLightRay(point, lightPos, rayLen);

    int stack[MAX_STACK_SIZE];
    stack[0] = 0;
    int cur = 0;

    const vec2 tmimaxInit = vec2(0.01, rayLen - 0.03);
    if (!doesIntersectAABB(0, tmimaxInit, lightRay)) {
        return false;
    }

    // Recursive test in the BVH
    while (cur >= 0) {
        int node = stack[cur];
        cur -= 1;

        // Leaf node
        if (leftChild(bvh[node]) <= 0) {
            float f = intersectTriangle(tris[-leftChild(bvh[node])], lightRay);
            if (tmimaxInit.x <= f && f < tmimaxInit.y) {
                return true;
            }

            continue;
        }

        if (doesIntersectAABB(leftChild(bvh[node]), tmimaxInit, lightRay)) {
            stack[cur + 1] = leftChild(bvh[node]);
            cur++;
        }

        if (doesIntersectAABB(rightChild(bvh[node]), tmimaxInit, lightRay)) {
            stack[cur + 1] = rightChild(bvh[node]);
            cur++;
        }
    }

    return false;
}

#else // USE_HW_RAYTRACING
bool testShadowAABB(SurfacePoint point, vec3 lightPos) {
    float rayLen;
    Ray lightRay = getLightRay(point, lightPos, rayLen);

    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, topLevelAS, gl_RayFlagsTerminateOnFirstHitEXT, 0xFF, point.worldPos, 0.01,
            lightRay.dir, rayLen - 0.03);

    // Traverse the acceleration structure and store information about the first intersection (if any)
    rayQueryProceedEXT(rayQuery);

    // If the intersection has hit a triangle, the fragment is shadowed
    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT) {
        return true;
    }

    return false;
}
#endif

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

PointLightParams getPointLight(int idx) {
    return computeLightParams(pointLights[idx]);
}

void getEmissiveTriangle(int idx, out float intensity, out vec3 N, out float area) {
    getEmissiveTriangleParams(emissiveTris[idx], intensity, N, area);
}

vec3 pickRndPointOnTriangle(vec3 a, vec3 b, vec3 c, inout uint rndState) {
    float r1 = nextRand(rndState);
    float r2 = nextRand(rndState);
    float s = 1 - sqrt(1 - r1);
    float t = (1 - s) * r2;
    return a + s * (b - a) + t * (c - a);
}

// Very naive lighting: shoot a ray to each light, bruteforce hit triangles.
vec3 naiveLighting(SurfacePoint point, float depth) {
    vec3 finalColor = vec3(0.0);
    for (int i = 0; i < nPointLights; i++) {
        PointLightParams light = computeLightParams(pointLights[i]);
        if (depth < 0.999 && !testShadowAABB(point, light.pos)) {
            float f = evalPointLightStrength(point, light) * slInfo.pointLightIntensityMultiplier;
            f *= evalFogAbsorption(point, slInfo);
            finalColor += f * light.color;
        }
    }

    return finalColor;
}

// Naive lighting: shoot a ray to each light source, but use BVH for shadow ray.
vec3 naiveLightingBVH(ivec2 pos, SurfacePoint point, float depth) {
    vec3 finalColor = vec3(0.0);
    for (int i = 0; i < nPointLights; i++) {
        PointLightParams light = computeLightParams(pointLights[i]);
        if (depth < 0.999 && !testShadowAABB(point, light.pos)) {
            float f = evalPointLightStrength(point, light) * slInfo.pointLightIntensityMultiplier;
            f *= evalFogAbsorption(point, slInfo);
            finalColor += f * light.color;
        }
    }

    uint rndState = getRandSeed(uvec3(pos, slInfo.randomSeed));

#define BRUTEFORCE_EMITTER_SAMPLES 50
#define BRUTEFORCE_AREA_SAMPLES 1
    for (int i = 0; i < BRUTEFORCE_EMITTER_SAMPLES; i++) {
        int emitterIdx = int(floor(nextRand(rndState) * nEmissiveTriangles));
        vec3 contrib = vec3(0);

        vec3 emitterN;
        float area, intensity;
        getEmissiveTriangle(emitterIdx, intensity, emitterN, area);

        for (int j = 0; j < BRUTEFORCE_AREA_SAMPLES; j++) {
            vec3 emitter = pickRndPointOnTriangle(
                    emissiveTris[emitterIdx].x.xyz, emissiveTris[emitterIdx].y.xyz, emissiveTris[emitterIdx].z.xyz, rndState);
            if (depth < 0.999 && !testShadowAABB(point, emitter)) {
                contrib += evalEmittingPoint(point, emitter, emitterN) * intensity * point.albedo *
                    emissiveTris[emitterIdx].emission.rgb;
            }
        }

        contrib *= evalFogAbsorption(point, slInfo);

        // Each sample has probability (1.0 / nEmissiveTriangles) * (1.0 / area)
        finalColor += contrib * area * nEmissiveTriangles / (BRUTEFORCE_AREA_SAMPLES * BRUTEFORCE_EMITTER_SAMPLES);
    }

    return finalColor;
}

int sampleEmissiveTriangleUniform(inout uint rndState, out float p) {
    p = 1.0 / nEmissiveTriangles;
    return int(floor(nextRand(rndState) * nEmissiveTriangles));
}

int sampleFromGridCell(inout uint rndState, int gX, int gY, inout float p) {
    const uint idx = gX * lightGridSize.y + gY;

    const int rangeStart = lightGridStartOffset[idx];
    const int rangeEnd = lightGridStartOffset[idx+1];
    const int rangeLen = max(1, rangeEnd - rangeStart);

    const uint bits = nextRand16bit(rndState);
    p *= 1.0 / rangeLen;
    return lightGrid[rangeStart + bits % rangeLen];
}

struct LightGridCache {
    float a;
    float mid;
    float b;
    float mPoint;
};

float invAlpha;

float lightGridCDF(LightGridCache cache, float x) {
    if (x < cache.mid) {
        return cache.mPoint * pow((x - cache.a) / (cache.mid - cache.a), invAlpha);
    } else {
        return (1.0 - cache.mPoint) * (1 - pow((x - cache.b) / (cache.mid - cache.b), invAlpha)) + cache.mPoint;
    }
}

float lightGridCDF(LightGridCache cache, float x, float y) {
    const float v1 = lightGridCDF(cache, x);
    const float v2 = lightGridCDF(cache, y);
    return (v1 - v2);
}

float lightGridInvCDF(LightGridCache cache, float x) {
    if (x < cache.mPoint) {
        return pow(x/cache.mPoint, slInfo.restirLightGridSearchAlpha) * (cache.mid - cache.a) + cache.a;
    } else {
        return pow(1.0 - (x-cache.mPoint)/(1-cache.mPoint), slInfo.restirLightGridSearchAlpha) * (cache.mid - cache.b) + cache.b;
    }
}

float lightGridUCDF(LightGridCache cache, float x, float y) {
    return (y - x) / (cache.b - cache.a);
}

float lightGridInvUCDF(LightGridCache cache, float x) {
    return cache.a + x * (cache.b - cache.a);
}

int sampleEmissiveTriangleLightGrid(inout uint rndState, SurfacePoint point, LightGridCache cacheX, LightGridCache cacheY, inout float p) {

    const vec2 ksi = nextRandV2(rndState);
    vec2 chosenPoint;
    if (slInfo.restirSamplingMode == 0) {
        chosenPoint = vec2(
                lightGridInvCDF(cacheX, ksi.x),
                lightGridInvCDF(cacheY, ksi.y));
    } else {
        chosenPoint = vec2(
                lightGridInvUCDF(cacheX, ksi.x),
                lightGridInvUCDF(cacheY, ksi.y));
    }

    // Calculate the probability that we chose that cell.
    // Each cell has an interval of points for which it is chosen (after int(floor(point)))).
    // So we can calculate the interval that this point belongs to, intersect it with the full
    // interval and thus know its probability.
    const vec2 chosenIntervalStart = max(floor(chosenPoint), vec2(cacheX.a, cacheY.a));
    const vec2 chosenIntervalEnd = min(ceil(chosenPoint), vec2(cacheX.b, cacheY.b));
    const ivec2 chosenCell = min(ivec2(floor(chosenPoint)), lightGridSize - 1);

    if (slInfo.restirSamplingMode == 0) {
        p *= lightGridCDF(cacheX, chosenIntervalStart.x, chosenIntervalEnd.x);
        p *= lightGridCDF(cacheY, chosenIntervalStart.y, chosenIntervalEnd.y);
    } else {
        p *= lightGridUCDF(cacheX, chosenIntervalStart.x, chosenIntervalEnd.x);
        p *= lightGridUCDF(cacheY, chosenIntervalStart.y, chosenIntervalEnd.y);
    }

    // Choose light from inside light grid cell
    return sampleFromGridCell(rndState, chosenCell.x, chosenCell.y, p);
}

bool binaryChoice(inout uint rndState, float w, out float p) {
    if (nextRand(rndState) <= w) {
        p = w;
        return true;
    }

    p = (1.0 - w);
    return false;
}

float fixFireflies(float p, float pHat) {
    if (p > 1e-4) {
        return pHat / p;
    }

    return clamp(pHat/p, 0, 10);
}

// Restir Step 1: fill reservoirs for each pixel
Reservoir fillReservoir(ivec2 pos, SurfacePoint point, float depth, inout uint rndState) {
//    uint rndState = getRandSeed(uvec3(pos, 0));
    Reservoir r = createEmptyReservoir();
    if (depth > 0.999) {
        return r;
    }

    LightGridCache cacheX, cacheY;

    const vec2 gridPos = clamp(point.worldPos.xy / lightGridCellSize + lightGridOffset, vec2(0), lightGridSize);
    const vec2 startSample = max(gridPos - slInfo.restirLightGridRadius, vec2(0));
    const vec2 endSample = min(gridPos + slInfo.restirLightGridRadius, lightGridSize);
    const vec2 mPoint = (gridPos - startSample) / (endSample - startSample);
    invAlpha = 1.0 / slInfo.restirLightGridSearchAlpha;

    cacheX.a = startSample.x;
    cacheX.b = endSample.x;
    cacheX.mid = gridPos.x;
    cacheX.mPoint = mPoint.x;

    cacheY.a = startSample.y;
    cacheY.b = endSample.y;
    cacheY.mid = gridPos.y;
    cacheY.mPoint = mPoint.y;

    int totalNum = nPointLights + nEmissiveTriangles;
    for (int i = 0; i < slInfo.restirInitialSamples; i++) {
        float p;
        if (binaryChoice(rndState, slInfo.restirPointLightImportance, p)) {
            int lightIdx = int(floor(nextRand(rndState) * nPointLights));
            PointLightParams params = computeLightParams(pointLights[lightIdx]);
            float pHat = evalPointLightStrength(point, params) * slInfo.pointLightIntensityMultiplier;
            p *= 1.0 / nPointLights;
            float w = fixFireflies(p, pHat);
            addSample(r, rndState, lightIdx+1, w, pHat, params.pos);
        } else {
            int triIdx;
            if (slInfo.restirSamplingMode == 2) {
                triIdx = sampleEmissiveTriangleUniform(rndState, p);
            } else {
                triIdx = sampleEmissiveTriangleLightGrid(rndState, point, cacheX, cacheY, p);
            }

            if (p <= 0 || isnan(p)) {
                // Bad samples can happen because of numerical issues.
                continue;
            }

            vec3 emitterN;
            float area, intensity;
            getEmissiveTriangle(triIdx, intensity, emitterN, area);
            vec3 emitterPoint = pickRndPointOnTriangle(
                    emissiveTris[triIdx].x.xyz, emissiveTris[triIdx].y.xyz, emissiveTris[triIdx].z.xyz, rndState);

            float pHat = evalEmittingPoint(point, emitterPoint, emitterN) * intensity;
            p *= 1.0 / area;
            float w = fixFireflies(p, pHat);
            addSample(r, rndState, -triIdx-1, w, pHat, emitterPoint);
        }
    }

    // Test visibility and reject samples if that is the case.
    // No need to waste time with them, we hope to get more samples with Spatial and Temporal reuse.
    for (int i = 0; i < NUM_SAMPLES_PER_RESERVOIR; i++) {
        float p = 0.0;
        if (r.selected[i] < 0) {
            vec3 emitterN;
            float area, intensity;
            getEmissiveTriangle(-r.selected[i]-1, intensity, emitterN, area);
            p = 1.0 / (area * totalNum);
        } else if (r.selected[i] > 0) {
            p = 1.0 / totalNum;
        }

        if (testShadowAABB(point, r.position[i])) {
            // Lies in shadow => ignore
            r.selected[i] = 0;
            r.pHat[i] = 0;
        }
    }

    return r;
}

void temporalReuse(ivec2 pos, SurfacePoint point, float depth) {
    uint rndState = getRandSeed(uvec3(pos, slInfo.randomSeed));
    Reservoir r = fillReservoir(pos, point, depth, rndState);

    int rIdx = reservoirIdx(pos, slInfo.viewportWidth);

    bool allowReuse = false;
    if (slInfo.restirTemporalFactor > 0 && depth < 0.999) {
        ivec2 resolution = textureSize(motion, 0);

        vec2 motion = texelFetch(motion, pos, 0).xy * 0.5 * vec2(resolution);
        ivec2 uv = ivec2(round(pos + motion));
        if (all(greaterThanEqual(uv, ivec2(0,0))) && all(lessThan(uv, resolution))) {
            // TODO: reconstruct positions, that should give even more precise results
            float prevDepth = texelFetch(prevDepth, uv, 0).r;
            if (abs(prevDepth - depth) < 0.1) {
                vec3 prevNormal = texelFetch(prevNormal, uv, 0).xyz;
                if (dot(prevNormal, point.N) > 0.5) {
                    vec3 prevAlbedo = texelFetch(prevAlbedo, uv, 0).rgb;
                    prevAlbedo -= point.albedo;
                    if (dot(prevAlbedo, prevAlbedo) < 0.1) {
                        allowReuse = true;
                    }
                }
            }

            if (allowReuse) {
                // We can reuse samples!
                int prevRIdx = reservoirIdx(uv, slInfo.viewportWidth);
                tryMergeReservoir(rndState, r, reservoirsOld[prevRIdx],
                        slInfo.restirTemporalFactor * r.totalNumSamples, slInfo, point);
            }
        }
    }

    reservoirsTmp[rIdx] = r;
}

void main()
{
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    if (pos.x > slInfo.viewportWidth || pos.y > slInfo.viewportHeight) {
        return;
    }

    float depth = texelFetch(depth, pos, 0).r;

    SurfacePoint point;
    point.worldPos = calculatePosition(depth, vec2(pos), slInfo);
    point.albedo = texelFetch(albedo, pos, 0).rgb;

    vec4 N = texelFetch(normal, pos, 0);
    point.N = N.xyz;

    vec3 color = vec3(1, 0, 0);
    if (slInfo.lightAlgo == 0) {
        temporalReuse(pos, point, depth);
        return;
    } else if (slInfo.lightAlgo == 1) {
        color = naiveLighting(point, depth);
    } else if (slInfo.lightAlgo == 2) {
        color = naiveLightingBVH(pos, point, depth);
    }

    imageStore(compositeLight, ivec2(pos), vec4(color, 1.0));
}
