#version 450

layout(std430, binding = 0) buffer UpBufferMetadata
{
    uint upSize;
    uint upCount;
    uint upBitmap[];
} upBufferMetadata;

layout(std430, binding = 1) buffer UpTransformBuffer
{
    mat4 upTransforms[];
} upTransformBuffer;

layout(std430, binding = 2) buffer BufferMetadata
{
    uint size;
    uint count;
    uint bitmap[];
} bufferMetadata;

layout(std430, binding = 3) buffer TransformBuffer
{
    mat4 transforms[];
} transformBuffer;

layout(std430, binding = 4) buffer DownBufferMetadata
{
    uint downSize;
    uint downCount;
    uint downBitmap[];
} downBufferMetadata;

layout(std430, binding = 5) buffer DownTransformBuffer
{
    mat4 downTransforms[];
} downTransformBuffer;

layout( push_constant ) uniform PushConstant {
    // x hasHigher
    // y hasLower
    // z lodDistMax
    // w lodDistMin
    vec4 lodMeta;
    vec3 cameraPosition;
} pushConstant;

//if distance does not fit current lod, move one level up or down through appending (atomic counter & bitmap)
void move(uint oldIdx, int upOrDown) {
    if (upOrDown == 0) return;
    else if (upOrDown == 1) {
        if (pushConstant.lodMeta.x < 0.5) return;
        uint newIdx = atomicAdd(upBufferMetadata.upSize, 1);
        upTransformBuffer.upTransforms[newIdx] = transformBuffer.transforms[oldIdx];
        atomicAdd(upBufferMetadata.upCount, 1);
        atomicAdd(bufferMetadata.count, -1);
        atomicAnd(bufferMetadata.bitmap[oldIdx/32], ~(1 << (oldIdx % 32)));
        atomicOr(upBufferMetadata.upBitmap[newIdx/32], 1 << (newIdx % 32));
    } else if (upOrDown == -1) {
        if (pushConstant.lodMeta.y < 0.5) return;
        uint newIdx = atomicAdd(downBufferMetadata.downSize, 1);
        downTransformBuffer.downTransforms[newIdx] = transformBuffer.transforms[oldIdx];
        atomicAdd(downBufferMetadata.downCount, 1);
        atomicAdd(bufferMetadata.count, -1);
        atomicAnd(bufferMetadata.bitmap[oldIdx/32], ~(1 << (oldIdx % 32)));
        atomicOr(downBufferMetadata.downBitmap[newIdx/32], 1 << (newIdx % 32));
    }
}

void main() {
    uint index = gl_GlobalInvocationID.x;

    /*
    atomicAnd(bufferMetadata.bitmap[0], 0u);
    atomicOr(bufferMetadata.bitmap[0], 1u);
    atomicAnd(bufferMetadata.bitmap[1], 0u);
    atomicOr(bufferMetadata.bitmap[1], 2u);
    atomicAnd(bufferMetadata.bitmap[2], 0u);
    atomicOr(bufferMetadata.bitmap[2], 3u);
    atomicAnd(bufferMetadata.bitmap[3], 0u);
    atomicOr(bufferMetadata.bitmap[3], 4u);
        if (index % 2 == 0) {
            atomicAnd(bufferMetadata.bitmap[index/32 + 2], ~(1 << (index % 32)));
        } else {
            atomicOr(bufferMetadata.bitmap[index/32 + 2], 1 << (index % 32));
        }
    */
    if (index < bufferMetadata.count) {
        float distance = distance(transformBuffer.transforms[index][3].xyz, pushConstant.cameraPosition);
        int moveTo = int(distance > pushConstant.lodMeta.z) - int(distance < pushConstant.lodMeta.w);
        move(index, moveTo);
    }

}