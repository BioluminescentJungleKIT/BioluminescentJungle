#version 450
#include "noise3D.glsl"
#include "util.glsl"

layout(binding = 0) uniform UniformBufferObject {
    vec3 cameraPosition;
    float time;
    float timeDelta;
    int bufferflyVolumeTriangleCount;
} ubo;

layout(binding = 1) buffer Bufferflies
{
    PointLight utterflies[];
} b;

layout(std430, binding = 2) buffer BufferflyVolumeVertices
{
    vec3 vertices[];
} bvv;

vec3 noise3D(vec3 position, uint index, float time) {
    return vec3(
    snoise(position + vec3(312, 862, 150) * (index + time / length(vec3(312, 862, 150)))),
    snoise(position + vec3(567, 457, 184) * (index + time / length(vec3(567, 457, 184)))),
    snoise(position + vec3(981, 217, 824) * (index + time / length(vec3(981, 217, 824))))
    );  // yes they are correllated, no i dont care.
}

// better use precomputed
vec3 calculateNormalOfNthTriangle(int n) {
    vec3 a = bvv.vertices[n * 3 + 0];
    vec3 b = bvv.vertices[n * 3 + 1];
    vec3 c = bvv.vertices[n * 3 + 2];

    return cross(b - a, c - a);
}

// from https://github.com/embree/embree/blob/master/tutorials/common/math/closest_point.h (Apache 2.0)
vec3 closestPointTriangle(const vec3 p, const vec3 a, const vec3 b, const vec3 c)
{
    const vec3 ab = b - a;
    const vec3 ac = c - a;
    const vec3 ap = p - a;

    const float d1 = dot(ab, ap);
    const float d2 = dot(ac, ap);
    if (d1 <= 0.f && d2 <= 0.f) return a;

    const vec3 bp = p - b;
    const float d3 = dot(ab, bp);
    const float d4 = dot(ac, bp);
    if (d3 >= 0.f && d4 <= d3) return b;

    const vec3 cp = p - c;
    const float d5 = dot(ab, cp);
    const float d6 = dot(ac, cp);
    if (d6 >= 0.f && d5 <= d6) return c;

    const float vc = d1 * d4 - d3 * d2;
    if (vc <= 0.f && d1 >= 0.f && d3 <= 0.f)
    {
        const float v = d1 / (d1 - d3);
        return a + v * ab;
    }

    const float vb = d5 * d2 - d1 * d6;
    if (vb <= 0.f && d2 >= 0.f && d6 <= 0.f)
    {
        const float v = d2 / (d2 - d6);
        return a + v * ac;
    }

    const float va = d3 * d6 - d5 * d4;
    if (va <= 0.f && (d4 - d3) >= 0.f && (d5 - d6) >= 0.f)
    {
        const float v = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return b + v * (c - b);
    }

    const float denom = 1.f / (va + vb + vc);
    const float v = vb * denom;
    const float w = vc * denom;
    return a + v * ab + w * ac;
}

float calculateSignedSquaredDistanceOfNthTriangle(int n, vec3 position) {
    vec3 diff = position -
    closestPointTriangle(
    position,
    bvv.vertices[n * 3 + 0],
    bvv.vertices[n * 3 + 1],
    bvv.vertices[n * 3 + 2]
    );
    return dot(diff, diff) * sign(dot(diff, calculateNormalOfNthTriangle(n)));
}


void main() {
    uint index = gl_GlobalInvocationID.x;
    vec3 random = noise3D(b.utterflies[index].position.xyz * 3, index * 10, ubo.time);
    vec3 cameraVector = ubo.cameraPosition - b.utterflies[index].position.xyz;
    // initialize random position
    b.utterflies[index].position.xyz += (random * 15 + ubo.cameraPosition) * int(dot(cameraVector, cameraVector) > 10000 || b.utterflies[index].position.xyz == vec3(0,0,0));

    // This is probably suboptimal, but it might work for near-convex meshes. Maybe we could only consider
    // the 2 or 3 nearest triangles or something like that, but there would always be an egde case of some
    // shape where it could break. Ideally, we'd compute if we are inside or outside the mesh (e.g. compute
    // and count in/out ray-intersections), or even a correct sdf, but that would probably be even more
    // expensive.
    vec3 volumeForce = vec3(0);
    for (int i = 0; i < ubo.bufferflyVolumeTriangleCount; i++) {
        vec3 diff = b.utterflies[index].position.xyz -
        closestPointTriangle(
        b.utterflies[index].position.xyz,
        bvv.vertices[i * 3 + 0],
        bvv.vertices[i * 3 + 1],
        bvv.vertices[i * 3 + 2]
        );
        volumeForce += (1 - smoothstep(0, 2, dot(diff, diff))) * normalize(diff) * 0.5;
    }
    //volumeForce = clamp(volumeForce, -0.1, 0.1);

    // move towards camera if far away, no LoD needed ;)
    vec3 cameraForce = cameraVector * smoothstep(30, 100, dot(cameraVector, cameraVector)) * 0.1;

    b.utterflies[index].velocity.xyz += (random * vec3(1,1,0.1) + cameraForce + volumeForce) * ubo.timeDelta;

    b.utterflies[index].velocity.xyz = clamp(b.utterflies[index].velocity.xyz, vec3(-1, -1, -1), vec3(1, 1, 1));
    float speed = length(b.utterflies[index].velocity);
    b.utterflies[index].velocity.xyz = clamp(b.utterflies[index].velocity.xyz, vec3(-1, -1, speed * -0.2), vec3(1, 1, speed * 0.2));

    b.utterflies[index].position.xyz += b.utterflies[index].velocity.xyz * ubo.timeDelta;
    //b.utterflies[index].position = vec3(0,0,0);
}
